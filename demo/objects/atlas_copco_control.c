/**
 * Generated by anjay_codegen.py on 2023-05-18 14:54:49
 *
 * LwM2M Object: Atlas Copco Control
 * ID: 9999, URN: , Optional, Single
 *
 * Various control parameters for Atlas Copco.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_memory.h>

/**
 * Data Rate: RW, Single, Mandatory
 * type: integer, range: N/A, unit: N/A
 * The maximum data rate in commands per millisecond at which SEND
 * commands can be executed.
 */
#define RID_DATA_RATE 0

typedef struct atlas_copco_control_object_struct {
    const anjay_dm_object_def_t *def;

    // TODO: object state
    int32_t data_rate;
} atlas_copco_control_object_t;

static inline atlas_copco_control_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, atlas_copco_control_object_t, def);
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;
    (void) iid;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    // TODO: instance reset

    // TODO: return 0 on success, negative value on failure
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_DATA_RATE,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;
    (void) iid;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_DATA_RATE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, (int32_t) obj->data_rate); // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx) {
    (void) anjay;
    (void) iid;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_DATA_RATE: {
        assert(riid == ANJAY_ID_INVALID);
        int32_t value; // TODO
        int result;
        if ((result = anjay_get_i32(ctx, &value))) {
            return result;
        } else if (value < 0) {
            return ANJAY_ERR_BAD_REQUEST;
        }

        obj->data_rate = (uint32_t) value;
        return 0;
    }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 9999,
    .handlers = {
        .list_instances = anjay_dm_list_instances_SINGLE,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_write = resource_write,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};

const anjay_dm_object_def_t **atlas_copco_control_object_create(void) {
    atlas_copco_control_object_t *obj = (atlas_copco_control_object_t *) avs_calloc(1, sizeof(atlas_copco_control_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void atlas_copco_control_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        atlas_copco_control_object_t *obj = get_obj(def);

        // TODO: object cleanup

        avs_free(obj);
    }
}
