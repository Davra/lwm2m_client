/**
 * Generated by anjay_codegen.py on 2023-06-01 16:30:28
 *
 * LwM2M Object: Atlas Copco Control
 * ID: 9999, URN: , Optional, Single
 *
 * Various control parameters for Atlas Copco.
 */
#include <assert.h>
#include <stdbool.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <errno.h>

#include "../objects.h"

#include <anjay/lwm2m_send.h>
#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_memory.h>
#include <avsystem/commons/avs_log.h>

/**
 * Data Rate: RW, Single, Mandatory
 * type: integer, range: N/A, unit: N/A
 * The maximum data rate in commands per millisecond at which SEND
 * commands can be executed.
 */
#define RID_DATA_RATE 0

/**
 * Peripheral IPv4 Address: RW, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * The IPv4 address of the peripheral
 */
#define RID_PERIPHERAL_IPV4_ADDRESS 1

/**
 * Peripheral peripheral_port: RW, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * The IPv4 address of the peripheral
 */
#define RID_PERIPHERAL_PORT 2

/**
 * BASH Command: RW, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * The command to execute in the BASH Execute action
 */
#define RID_BASH_COMMAND 3

/**
 * BASH Execute: E, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * The BASH Execute action defined from the BASH Command string
 */
#define RID_BASH_EXECUTE 4

typedef struct atlas_copco_control_object_struct
{
    const anjay_dm_object_def_t *def;

    // TODO: object state
    int32_t data_rate;
    char peripheral_ipv4_addr[256];
    char bash_command[256];
    char peripheral_port[256];
} atlas_copco_control_object_t;

static inline atlas_copco_control_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr)
{
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, atlas_copco_control_object_t, def);
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid)
{
    (void)anjay;
    (void)iid;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    // TODO: instance reset

    // TODO: return 0 on success, negative value on failure
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx)
{
    (void)anjay;
    (void)obj_ptr;
    (void)iid;

    anjay_dm_emit_res(ctx, RID_DATA_RATE,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_PERIPHERAL_IPV4_ADDRESS,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_PERIPHERAL_PORT,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_BASH_COMMAND,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_BASH_EXECUTE,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx)
{
    (void)anjay;
    (void)iid;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid)
    {
    case RID_DATA_RATE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, (int32_t)obj->data_rate); // TODO

    case RID_PERIPHERAL_IPV4_ADDRESS:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, obj->peripheral_ipv4_addr); // TODO

    case RID_PERIPHERAL_PORT:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, obj->peripheral_port); // TODO

    case RID_BASH_COMMAND:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, obj->bash_command); // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx)
{
    (void)anjay;
    (void)iid;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid)
    {
    case RID_DATA_RATE:
    {
        assert(riid == ANJAY_ID_INVALID);
        int32_t value; // TODO
        int result;
        if ((result = anjay_get_i32(ctx, &value)))
        {
            return result;
        }
        else if (value < 0)
        {
            return ANJAY_ERR_BAD_REQUEST;
        }
        obj->data_rate = (uint32_t)value;
        return 0;
    }

    case RID_PERIPHERAL_IPV4_ADDRESS:
    {
        assert(riid == ANJAY_ID_INVALID);
        char value[256];
        int result = anjay_get_string(ctx, value, sizeof(value));
        if (!result) {
            strcpy(obj->peripheral_ipv4_addr, value);
        }
        return result;
    }

    case RID_PERIPHERAL_PORT:
    {
        assert(riid == ANJAY_ID_INVALID);
        char value[256];
        int result = anjay_get_string(ctx, value, sizeof(value));
        if (!result) {
            strcpy(obj->peripheral_port, value);
        }
        return result;
    }

    case RID_BASH_COMMAND:
    {
        assert(riid == ANJAY_ID_INVALID);
        char value[256];
        int result = anjay_get_string(ctx, value, sizeof(value));
        if (!result) {
            strcpy(obj->bash_command, value);
        }
        return result;
    }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

int send_execute_command(char *bash_command, char *peripheral_ipv4_addr, char *peripheral_port)
{
    int sock = 0;
    struct sockaddr_in serv_addr;
    char buffer[1024] = {0};
    int port;


    // Creating socket
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("socket");
        return -1;
    }

    port = atoi(peripheral_port);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);

    // Converting IP address
    if (inet_pton(AF_INET, peripheral_ipv4_addr, &serv_addr.sin_addr) <= 0)
    {
        perror("Invalid address");
        return -1;
    }

    // Connecting to server
    int connect_result = connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    if (connect_result < 0)
    {
        perror("connect");
        printf("Error: %s\n", strerror(errno));
        return -1;
    }

    // Sending message
    send(sock, bash_command, strlen(bash_command), 0);

    // Receiving response
    read(sock, buffer, 1024);
    printf("Server response: %s\n", buffer);

    return 0;
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx)
{
    (void)anjay;
    (void)iid;
    (void)arg_ctx;

    atlas_copco_control_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid)
    {
    case RID_BASH_EXECUTE:
    {
        int result = send_execute_command(
            obj->bash_command, obj->peripheral_ipv4_addr, obj->peripheral_port);
        if (result == 0)
        {
            return ANJAY_SEND_OK;
        }
        else
        {
            return ANJAY_ERR_NOT_ACCEPTABLE;
        }
    }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 9999,
    .handlers = {
        .list_instances = anjay_dm_list_instances_SINGLE,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_write = resource_write,
        .resource_execute = resource_execute,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP}};

const anjay_dm_object_def_t **atlas_copco_control_object_create(void)
{
    atlas_copco_control_object_t *obj = (atlas_copco_control_object_t *)avs_calloc(1, sizeof(atlas_copco_control_object_t));
    if (!obj)
    {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void atlas_copco_control_object_release(const anjay_dm_object_def_t **def)
{
    if (def)
    {
        atlas_copco_control_object_t *obj = get_obj(def);

        // TODO: object cleanup

        avs_free(obj);
    }
}

static void send_finished_handler(anjay_t *anjay,
                                  anjay_ssid_t ssid,
                                  const anjay_send_batch_t *batch,
                                  int result,
                                  void *data)
{
    (void)anjay;
    (void)ssid;
    (void)batch;
    (void)data;

    if (result != ANJAY_SEND_SUCCESS)
    {
        avs_log(NULL, ERROR, "Send failed, result: %d", result);
    }
    else
    {
        avs_log(NULL, TRACE, "Send successful");
    }
}

void atlas_copco_control_object_send(anjay_t *anjay, const anjay_dm_object_def_t **def)
{
    if (!anjay || !def)
    {
        return;
    }
    atlas_copco_control_object_t *obj = get_obj(def);
    const anjay_ssid_t server_ssid = 1;

    // Allocate new batch builder.
    anjay_send_batch_builder_t *builder = anjay_send_batch_builder_new();

    if (!builder)
    {
        avs_log(obj, ERROR, "Failed to allocate batch builder");
        return;
    }

    int res = 0;

    atlas_copco_control_object_t it;

    // Add current values of resources from Time Object.
    if (anjay_send_batch_data_add_current(builder, anjay, obj->def->oid,
                                          0, RID_DATA_RATE))
    {
        anjay_send_batch_builder_cleanup(&builder);
        avs_log(obj, ERROR, "Failed to add batch data, result: %d",
                res);
        return;
    }

    // After adding all values, compile our batch for sending.
    anjay_send_batch_t *batch = anjay_send_batch_builder_compile(&builder);

    if (!batch)
    {
        anjay_send_batch_builder_cleanup(&builder);
        avs_log(obj, ERROR, "Batch compile failed");
        return;
    }

    // Schedule our send to be run on next `anjay_sched_run()` call.
    res = anjay_send(anjay, server_ssid, batch, send_finished_handler, NULL);

    if (res)
    {
        avs_log(obj, ERROR, "Failed to send, result: %d", res);
    }

    // After scheduling, we can release our batch.
    anjay_send_batch_release(&batch);
}
